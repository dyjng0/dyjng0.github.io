---
title: NahamCon CTF 2025 - Cryptoclock
date: 2025-05-24
categories:
  - CTF
tags:
  - CTF
  - crypto
  - xor
  - seed
---
# Source Code
```python
import socket
import threading
import time
import random
import os
from typing import Optional

def encrypt(data: bytes, key: bytes) -> bytes:
    """Encrypt data using XOR with the given key."""
    return bytes(a ^ b for a, b in zip(data, key))

def generate_key(length: int, seed: Optional[float] = None) -> bytes:
    """Generate a random key of given length using the provided seed."""
    if seed is not None:
        random.seed(int(seed))
    return bytes(random.randint(0, 255) for _ in range(length))

def handle_client(client_socket: socket.socket):
    """Handle individual client connections."""
    try:
        with open('flag.txt', 'rb') as f:
            flag = f.read().strip()
        
        current_time = int(time.time())
        key = generate_key(len(flag), current_time)
        
        encrypted_flag = encrypt(flag, key)
        
        welcome_msg = b"Welcome to Cryptoclock!\n"
        welcome_msg += b"The encrypted flag is: " + encrypted_flag.hex().encode() + b"\n"
        welcome_msg += b"Enter text to encrypt (or 'quit' to exit):\n"
        client_socket.send(welcome_msg)
        
        while True:
            data = client_socket.recv(1024).strip()
            if not data:
                break
                
            if data.lower() == b'quit':
                break
                
            key = generate_key(len(data), current_time)
            encrypted_data = encrypt(data, key)
            
            response = b"Encrypted: " + encrypted_data.hex().encode() + b"\n"
            client_socket.send(response)
            
    except Exception as e:
        print(f"Error handling client: {e}")
    finally:
        client_socket.close()

def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    server.bind(('0.0.0.0', 1337))
    server.listen(5)
    
    print("Server started on port 1337...")
    
    try:
        while True:
            client_socket, addr = server.accept()
            print(f"Accepted connection from {addr}")
            client_thread = threading.Thread(target=handle_client, args=(client_socket,))
            client_thread.start()
    except KeyboardInterrupt:
        print("\nShutting down server...")
    finally:
        server.close()

if __name__ == "__main__":
    main() 
```

## Code Analysis

The source code has good documentation so it isn't too difficult to understand what is happening. Data is encrypted using a simple `xor` algorithm with a key. Keys are generated by concatenating randomly generated bytes. The key generation also is seeded, which means that given two messages of the same length with the same seed, their key is the same.

Within the challenge oracle itself, the seed is generated based on the Unix timestamp for all messages in that oracle instance. In other words, the key to decrypt the flag is different across different oracles. Finally, the oracle itself is very straightforward--it first provides the encrypted flag, and then will print out the encrypted version of any plaintext sent to it.
# Approach

In order to decrypt the flag ciphertext, we first need to find the key. Since the key is determined by the length of the message of the flag and the seed, and we know that the seed is the same across all keys in the same oracle instance, then all we really need to find the key is the length of the flag. Let `length` be, fittingly, the length of the flag.

Using `pwn` to remotely connect to the oracle, the following code is a straightforward way to get exactly what we want.

```python
from pwn import remote, xor

HOST = "localhost"
PORT = "1337"

r = remote(HOST, PORT)

r.recvuntil(b"The encrypted flag is: ")
encrypted_flag = bytes.fromhex(r.recvline().strip().decode())
flag_length = len(encrypted_flag)

print(f"Encrypted Flag: {encrypted_flag}")
print(f"Flag Length: {flag_length}")
```

## Finding the Key

Recall that `0 ^ a = a` (a quick proof would just be to XOR `0` with `0` and `1` and see the result). In other words, if we send a byte string of $0$s to the oracle, it should spit out the key. Even more blunt, `000...0 ^ key = key`. We have the following code.

```python
byte_str = b"\x00" * flag_length
print(f"Sending byte string of length {flag_length}...")
r.sendline(byte_str)

r.recvuntil(b"Encrypted: ")
key = bytes.fromhex(r.recvline().strip().decode())
print(f"Flag Key: {key}")
r.close()
```

## Decryption

Now that we have the key, all we need to do is decrypt the flag. Another property of XOR is that if `a ^ b = c`, then `a ^ c = b` (again, a quick proof would be to exhaust all `a`, `b`, `c` options). Thus, we use the following code to decrypt the ciphertext.

```python
print("Decrypting flag...")
flag = xor(key, encrypted_flag)
print(flag)
```

# Full Code Solution

```python
from pwn import remote, xor

HOST = "localhost"
PORT = "1337"

r = remote(HOST, PORT)

r.recvuntil(b"The encrypted flag is: ")
encrypted_flag = bytes.fromhex(r.recvline().strip().decode())
flag_length = len(encrypted_flag)

print(f"Encrypted Flag: {encrypted_flag}")
print(f"Flag Length: {flag_length}")

byte_str = b"\x00" * flag_length
print(f"Sending byte string of length {flag_length}...")
r.sendline(byte_str)

r.recvuntil(b"Encrypted: ")
key = bytes.fromhex(r.recvline().strip().decode())
print(f"Flag Key: {key}")
r.close()

print("Decrypting flag...")
flag = xor(key, encrypted_flag)
print(flag)
```

After running the script, we get the following.

```
[+] Opening connection to localhost on port 1337: Done
Encrypted Flag: b't\xe3\x90:'
Flag Length: 4
Sending byte string of length 4...
Flag Key: b'2\xaf\xd1}'
[*] Closed connection to localhost port 1337
Decrypting flag...
b'FLAG'
```

There's our flag!
